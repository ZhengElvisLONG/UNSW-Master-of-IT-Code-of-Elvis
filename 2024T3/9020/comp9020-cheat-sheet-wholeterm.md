# COMP9020 Math Cheat Sheet
## 基础概念

- **Floor Function (下取整):** `⌊x⌋` 表示小于或等于 `x` 的最大整数。
- **Ceiling Function (上取整):** `⌈x⌉` 表示大于或等于 `x` 的最小整数。
- **Absolute Value (绝对值):** `|x|` 表示 `x` 的非负值。

#### 难点：
- 上下取整常用于简化整数计算。例如，若 `⌊x⌋ = ⌈x⌉`，则表明 `x` 必为整数。
- **例题**：证明 `⌊x⌋ = ⌈x⌉` 意味着 `x` 是整数。
  - **解答思路**：使用夹逼原理 `⌊x⌋ ≤ x ≤ ⌈x⌉`，当等号两边相等时，`x` 必为整数。

---

### 整除性与最大公约数 (GCD) 和最小公倍数 (LCM)

- **Divisibility (整除):** 如果存在整数 `k` 使得 `n = k * m`，则 `m` 整除 `n`，记作 `m | n`。
- **GCD (最大公约数)**：能同时整除 `m` 和 `n` 的最大整数。
- **LCM (最小公倍数)**：能同时被 `m` 和 `n` 整除的最小整数。
- **性质：** gcd 和 lcm 的关系为 `gcd(m, n) * lcm(m, n) = |m| * |n|`。

#### 难点：
- **例题**：证明如果 `ab | bc`，则 `a | c`。
  - **解答思路**：根据整除定义，`ab | bc` 表示存在整数 `k` 使 `bc = kab`，两边同除以 `b` 得 `c = ka`，故 `a | c`。

---

### 模运算与余数

- **定义:** `m div n = ⌊m/n⌋` 和 `m % n = m - n * ⌊m/n⌋`。
- **目标:** 给定整数 `m` 和 `n`，求 `m div n` 和 `m % n`。
- **技巧**：对大数取余时可寻找幂的循环模式，以简化计算。

#### 难点：
- **例题**：求 `7^7^7` 的最后两位。
  - **解答思路**：通过模 100 获取最后两位，对 `7` 的幂取模，找到循环规律 `74 ≡ 1 (mod 100)`，然后简化问题为 `73 % 100 = 43`。
### 例题 2：计算区间 20 到 365 中是 3 或 5 的倍数的整数个数

#### 解题思路

1. **容斥原理**：将问题分解为计算区间内是 3 的倍数、5 的倍数和 15（3 和 5 的最小公倍数）倍数的整数个数。

对于任意的区间 `[a, b]`，可以使用以下公式计算该区间内能被 `k` 整除的整数个数：

```
count(k) = floor(b / k) - floor((a - 1) / k)
```

其中，`floor(x)` 表示将 `x` 向下取整的操作。

在这个题目中，区间给定为 `[20, 365]`，即 `a = 20`，`b = 365`。接下来，我们计算区间 `[20, 365]` 中分别为 3、5 和 15 的倍数的整数个数：

1. **3 的倍数**：

   ```
   count(3) = floor(365 / 3) - floor(19 / 3)
   ```

2. **5 的倍数**：

   ```
   count(5) = floor(365 / 5) - floor(19 / 5)
   ```

3. **15 的倍数**（这是为了去除重复计数的部分）：

   ```
   count(15) = floor(365 / 15) - floor(19 / 15)
   ```

最后，为了计算区间内能被 3 或 5 整除的整数个数，可以通过容斥原理得到结果：

```
count(3 or 5) = count(3) + count(5) - count(15)
```

这里使用容斥原理的原因是，3 和 5 的倍数有一些重叠的部分（即同时是 15 的倍数的数），所以需要将这些重复计数的部分减去。
---


### 欧几里得算法 (Euclidean Algorithm)

- **算法概念:** 欧几里得算法通过递归计算来求解最大公约数 (GCD)，其规则如下：
  - 若 `gcd(m, n)`，则
    1. 当 `n = 0` 时，`gcd(m, 0) = m`。
    2. 否则，递归使用 `gcd(m % n, n)`，直到余数为 0。

#### 详细过程：
1. **步骤1**: 若 `a > b`，计算 `a % b` 得余数 `r`。
2. **步骤2**: 替换 `(a, b)` 为 `(b, r)`，重复步骤1，直到余数 `r = 0`。
3. **步骤3**: 最后一个非零余数即为 `gcd(a, b)`。

- **例题**：使用欧几里得算法计算 `(56, 72)` 的 GCD。
  - **解题过程**:
    1. `gcd(56, 72)`：计算 `72 % 56 = 16`，所以继续计算 `gcd(56, 16)`。
    2. `gcd(56, 16)`：计算 `56 % 16 = 8`，所以继续计算 `gcd(16, 8)`。
    3. `gcd(16, 8)`：计算 `16 % 8 = 0`，因此 `gcd(56, 72) = 8`。

---

### 重要结论

- **两个数互质的条件**：若 `gcd(a, b) = 1`，则称 `a` 和 `b` 为互质数。
- **连续整数的互质性**：任意整数 `n` 与 `n+1` 总是互质，因为其 GCD 必为 1。

---

### 练习题提示

- 对于模运算问题，如 `7^7^7` 的最后两位，可使用循环节来减少计算。
- 欧几里得算法是求解 gcd 的最有效方法，适用于大数。

## 集合论
### 集合概念与符号

- **集合 (Set)**：一组不重复对象的集合，用大写字母表示。
- **元素 (Element)**：`x ∈ A` 表示 `x` 是集合 `A` 的元素。
- **子集 (Subset)**：若 `A ⊆ B`，则 `A` 的所有元素均属于 `B`。
  - **真子集 (Proper Subset)**：若 `A ⊂ B` 且 `A ≠ B`，则 `A` 是 `B` 的真子集。
- **空集 (Empty Set)**：记作 `∅`，表示不包含任何元素的集合。
- **全集 (Universal Set)**：包含所有可能元素的集合，记作 `U`。

---

### 集合运算

- **并集 (Union)**：`A ∪ B = {x : x ∈ A or x ∈ B}`。
- **交集 (Intersection)**：`A ∩ B = {x : x ∈ A and x ∈ B}`。
- **补集 (Complement)**：`Ac = {x : x ∉ A and x ∈ U}`。
- **差集 (Difference)**：`A \ B = A ∩ Bc`，即 `A` 中不属于 `B` 的元素。
- **对称差 (Symmetric Difference)**：`A ⊕ B = (A \ B) ∪ (B \ A)`，包含仅在 `A` 或 `B` 中的元素。

#### 难点
- **例题**：证明对于任意集合 `A` 和 `B`，若 `A ⊆ B`，则 `A ∩ B = A`。
  - **解答思路**：
    1. **A ∩ B ⊆ A**：若 `x ∈ A ∩ B`，则 `x ∈ A`，所以 `A ∩ B ⊆ A`。
    2. **A ⊆ A ∩ B**：若 `x ∈ A` 且 `A ⊆ B`，则 `x ∈ B`，因此 `x ∈ A ∩ B`，得 `A ⊆ A ∩ B`。

---

### 幂集与基数

- **幂集 (Power Set)**：`Pow(A)` 表示所有 `A` 的子集构成的集合。
- **基数 (Cardinality)**：`|A|` 表示集合 `A` 的元素数量。

#### 难点
- **例题**：证明若 `A` 是含 `n` 个元素的有限集合，则 `|Pow(A)| = 2^n`。
  - **解答思路**：每个元素有包含或不包含两种选择，因此共有 `2^n` 个子集。

---

### 集合律与代数性质

- **交换律 (Commutativity)**：`A ∪ B = B ∪ A`，`A ∩ B = B ∩ A`。
- **结合律 (Associativity)**：`(A ∪ B) ∪ C = A ∪ (B ∪ C)`，`(A ∩ B) ∩ C = A ∩ (B ∩ C)`。
- **分配律 (Distribution)**：`A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)`，`A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)`。
- **德摩根律 (de Morgan's Laws)**：`(A ∩ B)c = Ac ∪ Bc`，`(A ∪ B)c = Ac ∩ Bc`。

#### 难点
- **例题**：证明 `A \ (A ∩ B) = A \ B`
  - **解答思路**：
    1. `A \ (A ∩ B) = A ∩ (A ∩ B)c`。
    2. 根据德摩根律 `(A ∩ B)c = Ac ∪ Bc`，将其代入得 `(A ∩ Ac) ∪ (A ∩ Bc) = ∅ ∪ (A ∩ Bc) = A \ B`。

---

### Venn 图示

Venn 图是一种用重叠圆圈展示集合关系的工具，便于直观理解集合运算。

#### 难点
- **例题**：利用 Venn 图证明 `A ∩ (B ∪ C) ≠ (A ∩ B) ∪ C`
  - **解答思路**：绘制两侧表达式的 Venn 图，观察其中差异。对于不同的情况选择元素验证左、右两式结果不等。

---

### 形式语言 (Formal Languages)

- **字母表 (Alphabet)**：有限的符号集，通常记作 `Σ`。
- **单词 (Word)**：由 `Σ` 中符号组成的有限序列。
- **语言 (Language)**：由 `Σ*` 中符合某种特定规则的单词集合。
- **闭包运算 (Kleene Star)**：`A*` 表示 `A` 的所有可能串联组合，包括空串。

#### 难点
- **例题**：给定 `A = {ab, ba}`，求 `A0`, `A1`, 和 `A2`。
  - **解答思路**：
    1. `A0 = {λ}` (空串)。
    2. `A1 = A = {ab, ba}`。
    3. `A2 = {abab, abba, baab, baba}`，即 `A` 中元素的所有两次串联组合。

---

### 语言的运算性质

- **串联 (Concatenation)**：`AB = {ab : a ∈ A and b ∈ B}`。
- **交集的闭包性**：如果 `w ∈ (L1 ∩ L2)*`，则 `w ∈ L1* ∩ L2*`。

#### 难点
- **例题**：证明 `(L1 ∩ L2)* ⊆ L1* ∩ L2*`
  - **解答思路**：
    1. 若 `w ∈ (L1 ∩ L2)*`，则 `w = w1w2...wn`，其中每个 `wi ∈ L1 ∩ L2`。
    2. 因为 `wi` 同时属于 `L1` 和 `L2`，因此 `w ∈ L1*` 且 `w ∈ L2*`，即 `w ∈ L1* ∩ L2*`。

---

### 重要结论

- **集合互斥性**：`A` 和 `Ac` 互为补集，因此 `A ∩ Ac = ∅` 且 `A ∪ Ac = U`。
- **幂集大小**：若集合 `A` 含有 `n` 个元素，则 `|Pow(A)| = 2^n`。
- **形式语言的运算封闭性**：语言 `A*` 包含所有可能的串联组合，是包含空串的无限集合。

---
## 关系
### 二元关系的定义
- **关系 (Relation)**：集合 `A` 和 `B` 之间的关系 `R` 是 `A × B` 的子集。如果 `(a, b) ∈ R`，则称 `a R b`。
- **图表示法**：用点代表元素，用箭头表示关系。
- **矩阵表示法**：在矩阵中用 `•` 表示关系 `(a, b) ∈ R`。
#### 难点：
- **例题**：给定 `A = {2, 3, 4, 6}` 和 `B = {1, 2, 3}`，`a R b` 表示 `gcd(a, b) = 1`。
  - **解答思路**：
    1. **关系集表示**：列出满足条件的 `(a, b)`。
    2. **图表示**：将关系绘制成带箭头的图。
    3. **矩阵表示**：在对应的矩阵位置填 `•`。
---
### 关系的运算
- **逆关系 (Converse)**：`R← = {(b, a) ∈ B × A : a R b}`。
- **复合关系 (Composition)**：`R;S = {(a, c) ∈ A × C : 存在 b ∈ B 使 a R b 且 b S c}`。
#### 难点：
- **例题**：计算 `R;R←`，并确定其是否为 `A × A` 的子集。
  - **解答思路**：逐一检查 `(a, c)` 是否存在 `b` 使得 `a R b` 且 `b R← c`，找出所有满足条件的 `(a, c)`。
---
### 关系的性质
- **自反性 (Reflexive)**：对于所有 `a ∈ A`，有 `(a, a) ∈ R`。
- **反自反性 (Antireflexive)**：对于所有 `a ∈ A`，有 `(a, a) ∉ R`。
- **对称性 (Symmetric)**：若 `(a, b) ∈ R`，则 `(b, a) ∈ R`。
- **反对称性 (Antisymmetric)**：若 `(a, b) ∈ R` 且 `(b, a) ∈ R`，则 `a = b`。
- **传递性 (Transitive)**：若 `(a, b) ∈ R` 且 `(b, c) ∈ R`，则 `(a, c) ∈ R`。
#### 难点：
- **例题**：确定 `R = {(a, b) ∈ Z×Z : a ≤ b}` 的自反性、对称性等性质。
  - **解答思路**：
    - **自反性**：`a ≤ a` 对所有 `a ∈ Z` 成立，故 `R` 自反。
    - **对称性**：若 `a < b`，则不一定有 `b < a`，故非对称。
    - **传递性**：若 `a ≤ b` 且 `b ≤ c`，则 `a ≤ c`，所以传递。

---

### 等价关系与等价类

- **等价关系 (Equivalence Relation)**：关系满足自反性、对称性和传递性。
- **等价类 (Equivalence Class)**：给定 `a ∈ A`，`[a] = {b ∈ A : a R b}`。

#### 难点：
- **例题**：证明 `w1 ∼ w2` 表示 `w1` 和 `w2` 含有相同字母数是等价关系。
  - **解答思路**：
    1. **自反性**：任意单词与自身含有相同字母数。
    2. **对称性**：若 `w1 ∼ w2`，则 `w2` 也与 `w1` 含相同字母数。
    3. **传递性**：若 `w1 ∼ w2` 且 `w2 ∼ w3`，则 `w1 ∼ w3`。

---

### 偏序关系与 Hasse 图

- **偏序关系 (Partial Order)**：关系满足自反性、反对称性和传递性。
- **Hasse 图**：用于表示偏序关系的简化图，仅显示具有直接关系的节点。
  - **极小元素**：没有其他元素小于该元素。
  - **极大元素**：没有其他元素大于该元素。

#### 难点：
- **例题**：在集合 `{2, 4, 6, 9, 12, 36, 72}` 上定义关系 `|`，绘制 Hasse 图并找出极小/极大元素。
  - **解答思路**：
    1. **Hasse 图**：将每个元素和其因子关系用箭头表示。
    2. **极小/极大元素**：找出图中没有指向的元素（极小）和没有被指向的元素（极大）。

---

### 格与全序关系

- **格 (Lattice)**：偏序集满足每对元素都有最小上界 (lub) 和最大下界 (glb)。
- **全序关系 (Total Order)**：所有元素对 `(a, b)` 中，满足 `a ≤ b` 或 `b ≤ a`。
- **拓扑排序 (Topological Sort)**：对偏序集进行全序排列，使得 `a ≤ b` 表示 `a` 排在 `b` 前。

#### 难点：
- **例题**：对偏序集 `Pow({a, b, c})` 进行拓扑排序。
  - **解答思路**：按子集的大小排序，得到 `{}`, `{a}`, `{b}`, `{c}`, `{a, b}`, `{a, c}`, `{b, c}`, `{a, b, c}`。

---

### 重要结论

- **自反性和对称性**：一个关系在满足对称和传递性时不一定自反，但若加上自反性，则为等价关系。
- **唯一极大元素**：偏序集中若存在极大元素，则该元素唯一。

---


# 关系的表示范例

### 关系的矩阵表示和图表示

**例题**：设集合 `A = {1, 2, 3}` 和 `B = {a, b}`，定义关系 `R ⊆ A × B` 满足以下条件：
- `(1, a), (2, a), (2, b)` 为 `R` 的元素。

我们可以将 `R` 表示成如下的矩阵和图：

#### 矩阵表示

|   | a | b |
|---|---|---|
| 1 | • |   |
| 2 | • | • |
| 3 |   |   |

- 其中 `•` 表示 `(a, b) ∈ R`。
- 行代表集合 `A` 的元素，列代表集合 `B` 的元素。

#### 图表示

```
A   B

1 → a
2 → a
2 → b
```

- 图表示法中，箭头从 `A` 中的元素指向 `B` 中的元素，以表示关系的方向。

---

### Hasse 图的范例

**例题**：设集合 `A = {1, 2, 4, 8}`，定义偏序关系 `|` (整除关系)，即若 `a | b`，则存在 `(a, b) ∈ R`。

#### Hasse 图表示

1. 绘制元素之间的整除关系，并只保留直接关系。
2. 省略自反关系 (即箭头自指) 和传递关系 (即间接整除)。
- 在 Hasse 图中，每个节点指向其被整除的元素，方向从下到上。
- `1` 是极小元素 (最小的整除因子)，`8` 是极大元素 (所有其他元素的倍数)。

---

## 布尔逻辑

- **布尔值集合**：`B = {0, 1}`，主要运算包括：
  - **非 (NOT)**：`!x = 1 - x`
  - **与 (AND)**：`x && y = min{x, y}`
  - **或 (OR)**：`x || y = max{x, y}`
- **布尔代数定律**：
  - **交换律**：`x || y = y || x`，`x && y = y && x`
  - **结合律**：`(x || y) || z = x || (y || z)`，`(x && y) && z = x && (y && z)`
  - **分配律**：`x || (y && z) = (x || y) && (x || z)`，`x && (y || z) = (x && y) || (x && z)`

#### 难点：
- **例题**：化简 `[x && (x && !y)] || [(x && y) || (y && !x)] = x || y`
  - **解答思路**：
    1. **观察整体结构**：将表达式分成几个小部分，尝试应用布尔代数的交换律、结合律、分配律逐步简化。
    2. **应用恒等律和补全律**：将不必要的项去除，使用 `x || (!x) = 1` 和 `x && (!x) = 0` 等基础公式。
    3. **整理结果**：最后得到简化形式 `x || y`。

---

### 函数与其性质

- **函数 (Function)**：对于集合 `X` 到 `Y` 的二元关系 `f ⊆ X × Y`，若每个 `x ∈ X` 对应唯一的 `y ∈ Y`，则 `f` 是一个函数。
- **单射 (Injective)**：若 `f(a) = f(b)` 则 `a = b`。
- **满射 (Surjective)**：对于每个 `y ∈ Y`，存在 `x ∈ X` 使得 `f(x) = y`。
- **双射 (Bijective)**：若函数既单射又满射。

#### 难点：
- **例题**：判断给定的二元关系是否为函数，并确定其定义域、值域和映射结果。
  - **解答思路**：
    1. **检查唯一性**：确保每个 `x ∈ X` 都对应唯一的 `y ∈ Y`。
    2. **确定函数的性质**：根据映射关系判断其是否为单射或满射。
    3. **求解定义域、值域和映射结果**：确认 `Dom(f)`、`Codom(f)` 和 `Im(f)`，理解函数的作用范围。

---

### 复合函数与逆函数

- **复合函数 (Composition)**：若 `f : X → Y` 和 `g : Y → Z`，则 `(g ◦ f)(x) = g(f(x))`。
- **逆函数 (Inverse Function)**：若 `f` 为双射，则存在唯一的逆函数 `f−1`，满足 `f−1(f(x)) = x` 且 `f(f−1(x)) = x`。

#### 难点：
- **例题**：证明 `g(x) = (x - 5) / 3` 是 `f(x) = 3x + 5` 的逆函数。
  - **解答思路**：
    1. **求解 `g(f(x))` 和 `f(g(x))`**：分别计算 `g(f(x))` 和 `f(g(x))`，验证结果为 `IdX` 和 `IdY`。
    2. **结论**：若 `g(f(x)) = x` 且 `f(g(x)) = x`，则 `g` 是 `f` 的逆函数。

---

### 主范式：合取范式 (CNF) 和析取范式 (DNF)

- **合取范式 (CNF)**：布尔表达式以**最大项**形式存在，即形如 `(m1 && m2 && ... && mn)` 的表达式。
- **析取范式 (DNF)**：布尔表达式以**最小项**形式存在，即形如 `(m1 || m2 || ... || mn)` 的表达式。

#### 难点：
- **例题**：将 `(x || y) && (!x || !y)` 转换为析取范式。
  - **解答思路**：
    1. **列出所有可能输入组合**：构建真值表，找出使表达式为真的组合。
    2. **写出对应的最小项**：对于每个满足条件的组合，写出相应的 `x` 和 `y` 形式的最小项。
    3. **组合最小项**：将所有满足条件的最小项用 `||` 连接起来，即得到析取范式结果 `(!x && y) || (x && !y)`。

---

### 大-O 记号

- **O-符号 (Big-O Notation)**：若 `f(n) ∈ O(g(n))`，则存在常数 `n0` 和 `c > 0`，使得对所有 `n ≥ n0`，有 `f(n) ≤ c * g(n)`。
- **Ω-符号 (Big-Omega Notation)**：若 `f(n) ∈ Ω(g(n))`，则存在常数 `n0` 和 `c > 0`，使得对所有 `n ≥ n0`，有 `f(n) ≥ c * g(n)`。
- **Θ-符号 (Big-Theta Notation)**：若 `f(n) ∈ Θ(g(n))`，则 `f(n)` 同时属于 `O(g(n))` 和 `Ω(g(n))`。

#### 难点：
- **例题**：确定 `f(n) = 4n + 2` 与 `g(n) = n^2 - 4` 的增长关系。
  - **解答思路**：
    1. **验证 O-记号条件**：找到 `c` 和 `n0` 使得对所有 `n ≥ n0`，`f(n) ≤ c * g(n)`，从而满足 `f(n) ∈ O(g(n))`。
    2. **验证 Ω-记号条件**：判断是否存在 `c` 和 `n0` 使得 `f(n) ≥ c * g(n)` 成立，若不满足则 `f(n) ∉ Ω(g(n))`。
    3. **综合结论**：若 `f(n)` 满足 `O(g(n))` 但不满足 `Ω(g(n))`，则 `f(n) ∉ Θ(g(n))`。

---

### 重要结论

- **布尔代数简化技巧**：使用交换、结合、分配、恒等、补全和幂等律简化复杂表达式。
- **双射函数的逆**：双射函数存在唯一的逆函数，满足 `f(f−1(x)) = x`。
- **大-O 符号的对偶关系**：若 `f(n) ∈ O(g(n))`，则 `g(n) ∈ Ω(f(n))`。

---

### 卡诺图 (Karnaugh Map)

- **定义**：卡诺图 (Karnaugh Map) 是一种简化布尔函数的方法，适用于2到4个变量的布尔表达式，帮助最小化最小项数量，以获得最简析取范式 (DNF) 表达式。
- **使用规则**：
  - 将布尔表达式中的每种变量组合在卡诺图上标出。
  - 通过合并相邻的“1”形成方块（覆盖区域），每个方块大小必须为 `2^n` (如1、2、4个格子)。
  - 方块可沿卡诺图边界环绕，找到覆盖所有“1”所需的最少方块数量。

#### 例题
- **题目**：将 `(x̄y) ∨ (xy)` 转换为最小项数量的析取范式 (DNF)。
  - **解题步骤**：
    1. **构建卡诺图**：将各项 `(x̄y)` 和 `(xy)` 的对应格子标记为“1”。
    2. **合并项**：观察相邻的“1”，合并成一个方块，尽量减少表达式中的项数。
    3. **写出最简表达式**：最终得到最小项形式。

---

### 逻辑符号 (Logical Symbols) 与逻辑运算

- **命题 (Proposition)**：能够判断真假（真/假）的陈述。
- **基本逻辑符号**：
  - `∧` (Conjunction)：和 (and)，表示“并且”。
  - `∨` (Disjunction)：或 (or)，表示“或”。
  - `¬` (Negation)：非 (not)，表示“不是”。
  - `→` (Implication)：条件 (if...then)，表示“若…则…”，充要条件。
  - `↔` (Biconditional)：双向条件 (if and only if)，表示“当且仅当”。

#### 难点题
- **例题**：将自然语言翻译为逻辑符号表示。
  - **题目**：若“天气晴朗”则“我会遛狗”。
  - **解题思路**：
    1. **定义命题符号**：假设 `p = “天气晴朗”` 和 `q = “我会遛狗”`。
    2. **转换为逻辑表达式**：根据题意，翻译为 `p → q`。

---

### 良构公式 (Well-Formed Formula, WFF)

- **定义**：良构公式 (WFF) 是满足逻辑结构和语法规范的公式，通常由基本命题和逻辑连接词构成。
- **构造规则**：
  - 单个命题变元、`>` (总真命题)、`⊥` (总假命题) 本身就是良构公式。
  - 若 `ϕ` 和 `ψ` 是良构公式，则 `¬ϕ`、`ϕ ∧ ψ`、`ϕ ∨ ψ`、`ϕ → ψ` 和 `ϕ ↔ ψ` 也是良构公式。

#### 例题
- **题目**：判断公式 `((p ∨ p) ∧ (p¬q))` 是否为良构公式。
  - **解题步骤**：
    1. **逐项分析**：检查每个子公式的结构是否符合良构公式的定义。
    2. **判断正确性**：确保每个逻辑操作符的用法和位置合理。例如，`p¬q` 不符合良构公式定义。

---

### 真值赋值 (Truth Assignment)

- **定义**：真值赋值是一种函数，为每个命题赋予一个真值（0表示假，1表示真）。
- **公式**：
  - `v(>) = 1`，表示恒为真；`v(⊥) = 0`，表示恒为假。
  - **逻辑运算**：
    - `v(¬ϕ) = 1 - v(ϕ)` (取反)。
    - `v(ϕ ∧ ψ) = min{v(ϕ), v(ψ)}` (取最小值表示与)。
    - `v(ϕ ∨ ψ) = max{v(ϕ), v(ψ)}` (取最大值表示或)。
    - `v(ϕ → ψ) = max{1 - v(ϕ), v(ψ)}` (条件运算)。
    - `v(ϕ ↔ ψ) = (1 + v(ϕ) + v(ψ)) % 2` (双向条件)。

#### 难点题
- **例题**：给定赋值 `v(p) = 1`，`v(q) = 0`，`v(r) = 1`，计算 `¬((p→ q) ∨ ¬r)` 的真值。
  - **解题步骤**：
    1. **计算内部子表达式**：首先求 `p → q` 和 `¬r` 的真值。
    2. **逐步代入求值**：根据给定赋值逐步代入每个子表达式的值，最后得出整个表达式的真值。

---

### 真值表 (Truth Table)

- **定义**：真值表用于枚举每种真值组合下逻辑表达式的结果。
- **结构**：每一行表示一种真值组合，列表示每个子公式的真值，最后一列为整个公式的真值。

#### 难点题
- **例题**：为命题 `¬((p ∧ q) → (p ∧ q))` 构建真值表。
  - **解题步骤**：
    1. **列出所有组合**：列出 `p` 和 `q` 的所有可能真值组合。
    2. **分步求解**：逐步计算子公式的真值，填入每一列。
    3. **得出最终结果**：最后一列显示整个公式的真值。

---

### 逻辑等价 (Logical Equivalence)

- **定义**：若公式 `ϕ` 和 `ψ` 在所有真值赋值下的结果相同，则称 `ϕ` 和 `ψ` 逻辑等价，记作 `ϕ ≡ ψ`。
- **证明方法**：
  - **真值表比较**：逐行检查真值表，确保所有组合下 `ϕ` 和 `ψ` 真值一致。
  - **使用等价律**：使用逻辑等价律直接变换。
  - **构建恒真公式**：证明 `ϕ ↔ ψ` 恒为真。

#### 难点题
- **例题**：证明 `¬p → (q ∨ r) ≡ q → (¬p → r)`。
  - **解题步骤**：
    1. **构建真值表**：列出所有可能的真值组合，计算每个表达式的真值。
    2. **比较结果**：逐行检查两边表达式的真值是否一致，以判断等价性。

---

### 蕴涵与有效性 (Entailment and Validity)

- **定义**：蕴涵关系 `ϕ1, ..., ϕn |= ψ` 表示在所有满足前提的真值赋值下，结论 `ψ` 也为真。
- **验证方法**：
  - **真值表法**：构建前提和结论的真值表，验证在所有前提为真时，结论也为真。
  - **恒真公式法**：证明 `(ϕ1 ∧ ... ∧ ϕn) → ψ` 恒为真。

#### 难点题
- **例题**：证明 `p ∧ ¬p |= q`。
  - **解题步骤**：
    1. **观察矛盾**：`p ∧ ¬p` 本身构成矛盾，逻辑上为假。
    2. **推导**：在矛盾条件下，可以推导出任意结论，因此 `p ∧ ¬p` 可以蕴涵任何命题 `q`。

---

### 逻辑等价律 (Logical Equivalence Laws)

- **常用等价律**：
  - **交换律 (Commutativity)**：`p ∨ q ≡ q ∨ p`，`p ∧ q ≡ q ∧ p`
  - **结合律 (Associativity)**：`(p ∨ q) ∨ r ≡ p ∨ (q ∨ r)`，`(p ∧ q) ∧ r ≡ p ∧ (q ∧ r)`
  - **分配律 (Distribution)**：`p ∨ (q ∧ r) ≡ (p ∨ q) ∧ (p ∨ r)`，`p ∧ (q ∨ r) ≡ (p ∧ q) ∨ (p ∧ r)`
  - **双重否定 (Double Negation)**：`¬¬p ≡ p`
  - **逆否命题 (Contrapositive)**：`p → q ≡ ¬q → ¬p`
  - **德摩根律 (De Morgan’s Laws)**：`¬(p ∨ q) ≡ ¬p ∧ ¬q`，`¬(p ∧ q) ≡ ¬p ∨ ¬q`

---

### 重要结论

- **逻辑等价的证明**：可以通过真值表、等价律或构造恒真公式来证明两个命题的等价性。
- **矛盾蕴涵**：在矛盾条件下，可以推导出任意结论，因此矛盾是逻辑上最强的蕴涵条件。

---


## 递归 (Recursion)

### 基础概念
递归包含以下两部分：
1. **基础情况 (Basis)**：定义初始项。
2. **递归关系 (Recurrence)**：通过前面的项定义后续项。

---

## 数学归纳法 (Mathematical Induction)

### 基础概念
归纳法用于证明命题 \( P(n) \) 对所有 \( n \geq m \) 成立。步骤如下：
1. **基础情况 (Base Case)**：验证 \( P(m) \) 成立。
2. **归纳假设 (Inductive Hypothesis)**：假设 \( P(k) \) 成立。
3. **归纳步骤 (Inductive Step)**：证明 \( P(k) \Rightarrow P(k+1) \)。

#### 例题 2
**问题**：证明 \( 1 + 2 + 4 + \dots + 2^n = 2^{n+1} - 1 \) 对所有 \( n \in \mathbb{N} \) 成立。

**解答思路**：
- **基础情况**：当 \( n = 0 \)，左边为 \( 1 \)，右边为 \( 2^1 - 1 = 1 \)。成立。
- **归纳假设**：假设 \( P(k) \) 成立，即 \( 1 + 2 + 4 + \dots + 2^k = 2^{k+1} - 1 \)。
- **归纳步骤**：对 \( P(k+1) \)：
\[
\begin{aligned}
1 + 2 + 4 + \dots + 2^k + 2^{k+1} &= (2^{k+1} - 1) + 2^{k+1} \\
&= 2^{k+2} - 1。
\end{aligned}
\]
因此，\( P(k+1) \) 成立。

结论：通过数学归纳法，命题对所有 \( n \in \mathbb{N} \) 成立。

---

## 主定理 (Master Theorem)

### 基础概念
对于递归式
\[
T(n) = aT\left(\frac{n}{b}\right) + f(n),
\]
设 \( d = \log_b a \)，则：
- **Case 1**：若 \( c < d \)，则 \( T(n) = \Theta(n^d) \)。
- **Case 2**：若 \( c = d \)，则 \( T(n) = \Theta(n^c \log n) \)。
- **Case 3**：若 \( c > d \)，则 \( T(n) = \Theta(f(n)) \)。

#### 例题 3
**问题**：求解以下递归的渐近复杂度：
1. \( T(n) = 8T(n/2) + 6n^3 \)
2. \( T(n) = 4T(n/5) + 2\log n \)
3. \( T(n) = T(n/2) + \sqrt{n}\log n \)

**解答思路**：
1. \( a = 8, b = 2, c = 3 \)，有 \( d = \log_2 8 = 3 \)。因为 \( c = d \)，故 \( T(n) = \Theta(n^3 \log n) \)。
2. \( a = 4, b = 5, c = 0 \)，有 \( d = \log_5 4 \)。因为 \( c < d \)，故 \( T(n) = \Theta(n^{\log_5 4}) \)。
3. \( a = 1, b = 2, c = 0.5 \)，有 \( d = 0 \)。因为 \( c > d \)，故 \( T(n) = \Theta(\sqrt{n}\log n) \)。

---

## 结构归纳法 (Structural Induction)

### 基础概念
对于递归定义的结构，通过结构归纳法证明性质。
1. **基础情况**：验证所有基础结构的命题成立。
2. **递归情况**：假设前序结构成立，证明递归结构成立。

#### 例题 4
**问题**：证明对于所有 \( w \in \Sigma^* \)，有 \( \text{length}(\text{rev}(w)) = \text{length}(w) \)，其中 \( \text{rev}(w) \) 是 \( w \) 的逆序。

**解答思路**：
1. **基础情况**：若 \( w = \lambda \)，则 \( \text{length}(\text{rev}(\lambda)) = \text{length}(\lambda) = 0 \)，成立。
2. **递归情况**：假设 \( \text{length}(\text{rev}(u)) = \text{length}(u) \)。对 \( w = xu \)：
\[
\text{length}(\text{rev}(xu)) = \text{length}(\text{rev}(u)x) = \text{length}(\text{rev}(u)) + 1 = \text{length}(u) + 1 = \text{length}(xu)。
\]
成立。

结论：通过结构归纳法，性质对所有 \( w \in \Sigma^* \) 成立。
---

## 组合数学 (Combinatorics)

### 集合的基本计数规则

#### 基础公式
1. \( |X \setminus Y| = |X| - |X \cap Y| \)
2. \( |X \cup Y| = |X| + |Y| - |X \cap Y| \)
3. \( |X \cup Y \cup Z| = |X| + |Y| + |Z| - |X \cap Y| - |Y \cap Z| - |Z \cap X| + |X \cap Y \cap Z| \)

#### 例题 1
**问题**：在 1 到 1000 的整数中，(a) 能被 2, 3 或 5 整除的有多少个？(b) 不能被 2, 3 或 5 整除的有多少个？

**解答思路**：
定义集合：
- \( U = \{x \in \mathbb{N} : x \in [1, 1000]\} \)
- \( A = \{x : 2 \mid x \} \), \( B = \{x : 3 \mid x\} \), \( C = \{x : 5 \mid x\} \)

通过容斥原理计算：
\[
|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |B \cap C| - |C \cap A| + |A \cap B \cap C|
\]
其中：
\[
\begin{aligned}
|A| &= \left\lfloor \frac{1000}{2} \right\rfloor = 500, \quad
|B| = \left\lfloor \frac{1000}{3} \right\rfloor = 333, \quad
|C| = \left\lfloor \frac{1000}{5} \right\rfloor = 200, \\
|A \cap B| &= \left\lfloor \frac{1000}{6} \right\rfloor = 166, \quad
|B \cap C| = \left\lfloor \frac{1000}{15} \right\rfloor = 66, \quad
|C \cap A| = \left\lfloor \frac{1000}{10} \right\rfloor = 100, \\
|A \cap B \cap C| &= \left\lfloor \frac{1000}{30} \right\rfloor = 33。
\end{aligned}
\]
代入公式得：
\[
|A \cup B \cup C| = 500 + 333 + 200 - 166 - 66 - 100 + 33 = 734。
\]
因此，不能被 2, 3 或 5 整除的数为 \( 1000 - 734 = 266 \)。

---

### 排列与组合

#### 基础公式
1. 排列数：  
   \( P(n, r) = n! / (n-r)! \)
2. 组合数：  
   \( C(n, r) = n! / [r!(n-r)!] \)

#### 例题 2
**问题**：将 20 个相同的气球和 32 个不同的棒棒糖分配给 4 个孩子，要求：
1. 每个孩子至少获得 1 个气球和 8 个棒棒糖。
2. 总共有多少种分配方式？

**解答思路**：
1. 对于气球的分配：
   - 去掉每人 1 个气球后分配剩余的 \( 20 - 4 = 16 \) 个气球。
   - 使用“组合有放回”的公式：  
     \( C(16 + 4 - 1, 16) = C(19, 16) \)。

2. 对于棒棒糖的分配：
   - 每人获得 8 个棒棒糖。
   - 第一位有 \( C(32, 8) \) 种选法，第二位有 \( C(24, 8) \)，以此类推。

最终答案：  
\( C(19, 16) \cdot C(32, 8) \cdot C(24, 8) \cdot C(16, 8) \cdot C(8, 8) \)

---

## 组合数学与概率重点复习

### **排列与组合的重难点知识**

1. **排列与组合的基本分类**  
排列与组合问题通常需要判断以下两点：
   - 是否允许重复抽取元素 (**With Replacement**)。
   - 抽取的顺序是否重要 (**Order Matters**)。

#### **分类公式汇总**  
| **With Replacement** | **Order Matters** | **公式**                   |
|-----------------------|-------------------|----------------------------|
| Yes                  | Yes               | \( n^k \)                  |
| No                   | Yes               | \( P(n, k) = n! / (n-k)! \) |
| No                   | No                | \( C(n, k) = n! / [k!(n-k)!] \) |
| Yes                  | No                | \( C(n + k - 1, k) \)      |

---

### **重要公式总结**

- **排列公式**：  
  \( P(n, k) = n! / (n-k)! \)，适用于无重复且顺序重要的场景。

- **组合公式**：  
  \( C(n, k) = n! / [k!(n-k)!] \)，适用于无重复且顺序不重要的场景。

- **重复组合公式**：  
  \( C(n + k - 1, k) \)，适用于允许重复且顺序不重要的场景。

- **全排列公式**：  
  \( n! \)，适用于无重复顺序的重要排列。

---

## 离散概率论 (Discrete Probability)

### 概率基础

1. **样本空间 (Sample Space)**：所有可能结果的集合，记作 Ω。
2. **事件 (Event)**：样本空间的子集。
3. **概率分布 (Probability Distribution)**：
   - P(Ω) = 1
   - 对于互斥事件 A 和 B，有 P(A ∪ B) = P(A) + P(B)。

#### 例题 3
**问题**：两个骰子同时掷出：
1. 骰子点数之和为 6 的概率是多少？
2. 至少有一个骰子出现偶数的概率是多少？

**解答思路**：
1. 样本空间大小为 |Ω| = 6 × 6 = 36。
   - 点数和为 6 的组合为 {(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)}，共有 5 种。
   - 概率为 P = 5 / 36。

2. 至少一个偶数：
   - 两个骰子全是奇数的概率为 P(全奇) = (3 / 6) × (3 / 6) = 1 / 4。
   - 至少一个偶数的概率为 P(至少一个偶数) = 1 - P(全奇) = 3 / 4。

---

### 条件概率与独立性

#### 条件概率公式
P(A | B) = P(A ∩ B) / P(B)

#### 独立性
若 P(A ∩ B) = P(A) × P(B)，则事件 A 和 B 独立。

#### 例题 4
**问题**：一个工厂有两条生产线：
- A 生产 60% 的产品，次品率为 3%；
- B 生产 40% 的产品，次品率为 2%。

随机选取一个次品，求其来自生产线 A 的概率。

**解答思路**：
1. 定义事件：
   - A：来自生产线 A；
   - D：为次品。

2. 使用全概率公式计算 P(D)：
P(D) = P(D | A) × P(A) + P(D | B) × P(B)  
P(D) = 0.03 × 0.6 + 0.02 × 0.4 = 0.026。

3. 条件概率公式求 P(A | D)：
P(A | D) = [P(D | A) × P(A)] / P(D)  
P(A | D) = (0.03 × 0.6) / 0.026 ≈ 0.69。

---

# 图论 Cheat Sheet

## **基础概念**

### **图的定义**
- **无向图**：边为无序对 \(\{x, y\}\)，顶点 \(x, y \in V\)，且 \(x \neq y\)。
- **有向图**：边为有序对 \((x, y)\)，表示从 \(x\) 指向 \(y\) 的一条边。

### **图的表示方法**
1. **图形表示**：顶点用点表示，边用线连接。
2. **邻接矩阵**：矩阵元素 \((i, j)\) 为 1 表示顶点 \(i, j\) 有边相连。
3. **邻接表**：每个顶点对应一个列表，列出与其相连的顶点。
4. **关联矩阵**：顶点为行，边为列，矩阵值表示顶点是否关联某条边。

#### **例题 1**
**问题**：无向图 \(G = (V, E)\)，其中 \(V = \{a, b, c, d, e\}\)，\(E = \{\{a, b\}, \{b, c\}, \{c, d\}, \{b, d\}\}\)。
1. 绘制图 \(G\)。
2. 写出其邻接矩阵、邻接表和关联矩阵。

**解答**：
1. 图形：顶点 \(a, b, c, d, e\) 用点表示，边用线连接。
2. **邻接矩阵**：
\[
\begin{bmatrix}
0 & 1 & 0 & 0 & 0 \\
1 & 0 & 1 & 1 & 0 \\
0 & 1 & 0 & 1 & 0 \\
0 & 1 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0
\end{bmatrix}
\]
3. **邻接表**：
\[
\begin{aligned}
a &: b \\
b &: a, c, d \\
c &: b, d \\
d &: b, c \\
e &: \emptyset
\end{aligned}
\]
4. **关联矩阵**：
\[
\begin{bmatrix}
1 & 0 & 0 & 0 \\
1 & 1 & 0 & 1 \\
0 & 1 & 1 & 0 \\
0 & 0 & 1 & 1 \\
0 & 0 & 0 & 0
\end{bmatrix}
\]

---

## **图的性质**

### **度数**
1. **无向图**：顶点 \(v\) 的度数 \(deg(v)\) 为与其相连的边数。  
   - 性质：\(\sum_{v \in V} deg(v) = 2|E|\)。
2. **有向图**：分为入度 \(indeg(v)\) 和出度 \(outdeg(v)\)。
   - 性质：\(\sum_{v \in V} indeg(v) = \sum_{v \in V} outdeg(v) = |E|\)。

#### **例题 2**
**问题**：计算以下图中各顶点的度数。
- 图 1：无向图 \((V, E)\)，\(V = \{a, b, c, d\}\)，\(E = \{\{a, b\}, \{b, c\}, \{c, d\}, \{d, a\}, \{b, d\}\}\)。
- 图 2：有向图 \(V = \{a, b, c\}\)，\(E = \{(a, b), (b, c), (c, a), (a, a)\}\)。

**解答**：
1. **图 1：无向图**
   \[
   \begin{aligned}
   deg(a) &= 2, \, deg(b) = 3, \, deg(c) = 2, \, deg(d) = 3.
   \end{aligned}
   \]
2. **图 2：有向图**
   \[
   \begin{aligned}
   outdeg(a) &= 2, \, indeg(a) = 1, \\
   outdeg(b) &= 1, \, indeg(b) = 1, \\
   outdeg(c) &= 1, \, indeg(c) = 2.
   \end{aligned}
   \]

---

## **路径与连通性**

### **路径类型**
1. **步 (Walk)**：顶点序列 \(v_0, v_1, \dots, v_n\)，边 \((v_{i-1}, v_i) \in E\)。
2. **轨迹 (Trail)**：步中无重复边。
3. **简单路径 (Path)**：步中无重复顶点。
4. **闭环 (Cycle)**：首尾相连的简单路径。

#### **例题 3**
**问题**：判断以下顶点序列的路径类型：
1. \(a \to b \to c \to d \to b \to e\)
2. \(a \to b \to c \to d \to c \to a\)
3. \(a \to c \to e\)

**解答**：
1. 步：重复顶点和边，非轨迹或路径。
2. 闭环：是一个首尾相连的简单路径。
3. 路径：没有重复顶点。

---

## **特殊图**

### **树**
- 定义：无环连通图，满足 \(|V| = |E| + 1\)。
- 叶子：度数为 1 的顶点。

#### **例题 4**
**问题**：证明树中至少有 2 个叶子顶点。

**解答**：
1. 树中 \(\sum_{v \in V} deg(v) = 2|E| = 2(|V| - 1)\)。
2. 若只有 1 个叶子，则无法保证度数和满足性质，故至少有 2 个叶子。

---

### **完全图与二分图**
1. **完全图 \(K_n\)**：所有顶点两两相连，边数 \(|E| = \binom{n}{2}\)。
2. **完全二分图 \(K_{m,n}\)**：两部分顶点间所有顶点相连，边数 \(|E| = m \cdot n\)。

---

## **Euler 和 Hamilton 问题**

### **Euler 路径与回路**
- **Euler 路径**：包含图中所有边，且无重复。
   - 条件：所有顶点度数为偶数或仅有 2 个顶点度数为奇数。
- **Euler 回路**：闭合的 Euler 路径。
   - 条件：所有顶点度数为偶数。

### **Hamilton 路径与回路**
- **Hamilton 路径**：经过每个顶点一次。
- **Hamilton 回路**：闭合的 Hamilton 路径。
   - 无通用判定方法。

---

## **图染色与平面性**

### **染色**
- 定义：为图的顶点分配颜色，要求相邻顶点颜色不同。
- **色数 \(\chi(G)\)**：最少颜色数。

### **平面图**
- 定义：图可以在平面上绘制，且无边交叉。
- 判定：图中不包含 \(K_5\) 或 \(K_{3,3}\) 的子图。

#### **例题 5**
**问题**：证明以下图为非平面图。
- 图中包含 \(K_5\) 的子图。

**解答**：通过找到 \(K_5\) 或 \(K_{3,3}\) 的子图即可证明非平面性。

---
根据您上传的文档内容，我为 **统计学** 和 **算法分析** 章节整理了重点内容及部分例题。以下是关键知识点与示例：

---

# **统计学重点整理**

## **随机变量与期望值**

### **随机变量**
1. 随机变量 \(X\)：将样本空间 \(\Omega\) 映射到整数或实数。
   - 例：\(X = \text{硬币正面次数}\)
2. 常见操作：
   - **加法**：\(X + Y = X(\omega) + Y(\omega)\)
   - **乘法**：\(X \cdot Y = X(\omega) \cdot Y(\omega)\)

### **期望值**
定义：\[
E(X) = \sum_{k \in \mathbb{Z}} P(X = k) \cdot k
\]
- 线性性质：\(E(aX + bY) = aE(X) + bE(Y)\)
- 独立同分布时：\(E(X_1 + \dots + X_n) = n \cdot E(X_1)\)

#### **例题：期望值计算**
**问题**：从一副 52 张牌中抽取一张，定义随机变量：
\[
X = \begin{cases} 
5 & \text{若是黑桃} \\
-2 & \text{若是红心} \\
0 & \text{其他}
\end{cases}
\]
求 \(E(X)\)。

**解答**：
1. 概率：\(P(\text{黑桃}) = \frac{13}{52} = \frac{1}{4}\)，\(P(\text{红心}) = \frac{1}{4}\)，其他 \(P = \frac{1}{2}\)。
2. 期望值：
\[
E(X) = 5 \cdot \frac{1}{4} + (-2) \cdot \frac{1}{4} + 0 \cdot \frac{1}{2} = \frac{5}{4} - \frac{2}{4} = \frac{3}{4}
\]

---

## **二项分布**
### 定义
对于 \(n\) 次独立实验，每次成功概率为 \(p\)，随机变量 \(X\) 表示成功次数，则
\[
P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}
\]
期望值与方差：
\[
E(X) = n \cdot p, \quad \text{Var}(X) = n \cdot p \cdot (1-p)
\]

#### **例题：垃圾邮件过滤器**
**问题**：某过滤器对垃圾邮件的识别率为 98%。每天收到 100 封邮件，其中 60% 是垃圾邮件。
1. 每天漏判垃圾邮件的期望值是多少？
2. 超过 3 封垃圾邮件漏判的概率是多少？

**解答**：
1. **期望值**：
   \(E(X) = n \cdot p = 60 \cdot 0.02 = 1.2\) 封。
2. **概率计算**：
   - 随机变量 \(X\)：漏判垃圾邮件数，服从 \(B(60, 0.02)\)。
   - \(P(X > 3) = 1 - P(X \leq 3)\)，用二项分布计算 \(P(X \leq 3)\)。

---

## **正态分布近似**
大样本情况下，二项分布 \(B(n, p)\) 可用正态分布 \(N(\mu, \sigma^2)\) 近似：
\[
\mu = n \cdot p, \quad \sigma^2 = n \cdot p \cdot (1-p)
\]

#### **例题：通信错误分析**
**问题**：二进制通信信道误码率为 0.1%，每个数据包包含 1000 位。
1. 每包期望错误数？
2. 超过 3 位错误的概率？

**解答**：
1. **期望值**：\(\mu = n \cdot p = 1000 \cdot 0.001 = 1\)。
2. **概率**：用正态分布近似，\(\sigma^2 = 0.999\)，标准化后计算。

---

# **算法分析重点整理**

## **时间复杂度分析**

### **基本操作**
- 算术操作、比较、赋值、返回值：\(\mathcal{O}(1)\)

### **循环时间复杂度**
- 单层循环：\(T(n) = b \cdot \mathcal{O}(1) \)。
- 嵌套循环：
\[
T(n) = \sum_{i=1}^n \mathcal{O}(i) = \mathcal{O}(n^2)
\]

#### **例题：嵌套循环**
**代码**：
```python
nested_power(n):
    for i in range(1, n+1):
        for j in range(1, i+1):
            result += j
```

**分析**：
1. 外层循环 \(i = 1 \to n\)，内层循环运行 \(i\) 次。
2. 总时间复杂度为 \(\sum_{i=1}^n i = \frac{n(n+1)}{2} = \mathcal{O}(n^2)\)。

---

## **递归时间复杂度**

### **递归关系**
递归复杂度可用递推式表示，常用主定理解决：
\[
T(n) = a \cdot T\left(\frac{n}{b}\right) + f(n)
\]
根据 \(d = \log_b a\) 比较 \(f(n)\) 增长：
1. \(f(n) = \mathcal{O}(n^d)\)：\(T(n) = \mathcal{O}(n^d \log n)\)。
2. \(f(n) < \mathcal{O}(n^d)\)：\(T(n) = \mathcal{O}(n^d)\)。

#### **例题：递归求解**
**代码**：
```python
bad_split(n):
    if n <= 0:
        return 0
    elif n % 2 == 1:
        return 1 + bad_split(n // 2)
    else:
        return 1 + bad_split(n // 4)
```

**解答**：
1. 递推式：\(T(n) = T(n/2) + \mathcal{O}(1)\)
2. 解法：用主定理得 \(T(n) = \mathcal{O}(\log n)\)。

---
